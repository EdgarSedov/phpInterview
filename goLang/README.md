## GoLang

**Go** (Golang) — компилируемый многопоточный язык программирования.

Язык Go разрабатывался как язык программирования для создания высокоэффективных программ, работающих на современных распределённых системах и многоядерных процессорах. Он может рассматриваться как попытка создать замену языкам Си и C++. По словам Роба Пайка, «Go был разработан для решения реальных проблем, возникающих при разработке программного обеспечения в Google». В качестве основных таких проблем он называет:

- медленную сборку программ;
- неконтролируемые зависимости;
- использование разными программистами разных подмножеств языка;
- затруднения с пониманием программ, вызванные неудобочитаемостью кода, плохим документированием и так далее;
- дублирование разработок;
- высокую стоимость обновлений;
- несинхронные обновления при дублировании кода;
- сложность разработки инструментария;
- проблемы межъязыкового взаимодействия.

Основными требованиями к языку стали:

- Ортогональность. Язык должен предоставлять небольшое число средств, не повторяющих функциональность друг друга.
- Простая и регулярная грамматика. Минимум ключевых слов, простая, легко разбираемая грамматическая структура, легко читаемый код.
- Простая работа с типами. Типизация должна обеспечивать безопасность, но не превращаться в бюрократию, лишь увеличивающую код. Отказ от иерархии типов, но с сохранением объектно-ориентированных возможностей.
- Отсутствие неявных преобразований.
- Сборка мусора.
- Встроенные средства распараллеливания, простые и эффективные.
- Поддержка строк, ассоциативных массивов и коммуникационных каналов.
- Чёткое разделение интерфейса и реализации.
- Эффективная система пакетов с явным указанием зависимостей, обеспечивающая быструю сборку.

Go — компилируемый язык. Предполагается, что программы на Go будут транслироваться компилятором в объектный код целевой аппаратной платформы и в дальнейшем исполняться непосредственно, не требуя виртуальной машины. Архитектура языка изначально проектировалась так, чтобы обеспечить быструю компиляцию в эффективный объектный код. Хотя для Go доступен и интерпретатор, практически в нём нет большой потребности, так как скорость компиляции достаточно высока для обеспечения интерактивной разработки.

## Concurrency(многозадачность)

В Go реализована высококлассная поддержка конкурентности, что является одним из важнейших преимуществ этого языка программирования. Механизмы реализации конкурентности Go основаны на работе Тони Хоара (Tony Hoare) [‘Communicating Sequential Processes’](http://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf).

**Среда исполнения Go позволяет выполнять сотни тысяч конкурентных горутин на одной машине.** Горутина — это легковесный поток выполнения. Go умеет мультиплексировать горутины в потоках ОС. То есть несколько горутин могут конкурентно выполняться в одном потоке операционной системы. В среде исполнения Go предусмотрен специальный планировщик, в задачу которого входит управление выполнением горутин.

У такого подхода есть два преимущества:

1. При инициализации горутина занимает в стеке лишь 4 KB. Это мизер по сравнению, например, с 1 мегабайтом, который обычно выделяется потоку операционной системы. Это число обретает значимость при необходимости конкурентного выполнения сотен тысяч различных горутин на одной машине. Если для этих целей использовать потоки ОС, оперативная память может очень быстро закончиться.

2. Go мог пойти по тому же пути, что и другие языки, например Java, в которой используются потоки операционной системы. Однако в этом случае цена переключения контекста между потоками ОС гораздо выше по сравнению с ценой переключения контекста между различными горутинами.

   

## Планировщик Go

Обычно есть 3 моделей для нарезания вычисления на потоки. Первым является N:1, где несколько пользовательских потоков запущено на едином потоке ядра операционной системы. Этот способ имеет то преимущество, что осуществляется очень быстрое переключение контекстов, но нет возможности воспользоваться преимуществами многоядерных систем. Второй способ — это 1:1, где каждый пользовательский поток выполнения совпадает с одним потоком операционной системы. Он использует все ядра автоматически, но переключение контекста происходит медленно, потому что требует прерываний работы операционной системы.

Go пытается взять лучшее из обоих миров с помощью М:N планировщика. При этом произвольное число Go-рутин (M) планируется на произвольное количество потоков (N) операционной системы. Этим вы получаете одновременно быстрое переключение контекста и возможность воспользоваться всеми ядрами в вашей системе. Основным недостатком данного подхода является сложность его включения в планировщик.  

 Чтобы исполнять задачу планирования, планировщик Go использует 3 основных сущностей:

![img](https://habrastorage.org/getpro/habr/post_images/b7f/950/7f2/b7f9507f25478708df83be3e4243f2a3.jpg)

Треугольник представляет поток операционной системы. Выполнением такого потока управляет операционная система, и работает это во многом подобно вашим стандартным потокам POSIX. В исполнимом коде это называется M машиной.

Круг представляет Go-рутину. Он включает стек, указатель команд и другую важную информацию для планирования Go-рутины, такую как канал, который на ней может быть блокирован. В исполнимом коде это обозначается как G.

Прямоугольник представляет контекст планирования. Вы можете понимать его как локализованная версию планировщика, который выполняет код Go-рутин в единственном потоке ядра. Это важная часть, которая позволяет нам уйти от N:1 планировщика к М:N планировщику. Во время выполнения кода контекст обозначается как P для процессора. В общем это и всё, если коротко.

![img](https://habrastorage.org/getpro/habr/post_images/ed6/195/c49/ed6195c49aad3cfa29b163492bd9cb0f.jpg)  

## Каналы 

### Устройство канала

Давайте начнём с разбора структуры канала:

![img](https://habrastorage.org/files/483/025/741/48302574178048caac81c816f9e37238.png)



- qcount — количество элементов в буфере
- dataqsiz — размерность буфера
- buf — указатель на буфер для элементов канала
- closed — флаг, указывающий, закрыт канал или нет
- recvq — указатель на связанный список горутин, ожидающих чтения из канала
- sendq -указатель на связанный список горутин, ожидающих запись в канал
- lock — мьютекс для безопасного доступа к каналу

В общем случае, горутина захватывает мьютекс, когда совершает какое-либо действие с каналом, кроме случаев lock-free проверок при неблокирующих вызовах (я объясню это подробнее чуть ниже). Closed — это флаг, который устанавливается в 1, если канал закрыт, и в 0, если не закрыт. Эти поля далее будут исключены из общей картины, для большей ясности.

Канал может быть синхронным (небуферизированным) или асинхронным (буферезированным). Давайте вначале посмотрим, как работают синхронные каналы.

### Синхронные каналы

Допустим, у нас есть следующий код:

```go
package main

func main() {
    ch := make(chan bool)
    go func() {
        ch <- true
    }()
    <-ch
}
```

Вначале создается новый канал и он выглядит вот так:

![img](https://habrastorage.org/files/725/298/c69/725298c69c2b4319b3cb5cf606712124.png)

Go не выделяет буфер для синхронных каналов, поэтому указатель на буфер равен nil и `dataqsiz`равен нулю. В приведённом коде нет гарантии, что случится первее — чтение из канала или запись, поэтому допустим, что первым действием будет чтение из канала (обратный пример, когда вначале идёт запись, будет рассмотрена ниже в примере с буферизированным каналами). Вначале, текущая горутина произведёт некоторые проверки, такие как: закрыт ли канал, буферизирован он или нет, содержит ли гоуртины в send-очереди. В нашем примере у канала нет ни буфера, ни ожидающих отправки горутин, поэтому горутина добавит сама себя в `recvq` и заблокируется. На этом шаге наш канал будет выглядеть следующим образом:

![img](https://habrastorage.org/files/2af/b2c/796/2afb2c79621847e0a28f118f92ed5c10.png)

Теперь у нас осталась только одна работающая горутина, которая пытается записать данные в канал. Все проверки повторяются снова, и когда горутина проверяет `recvq` очередь, она находит ожидающую чтение горутину, удаляет её из очереди, записывает данные в её стек и снимает блокировку. Это единственное место во всём рантайме Go, когда одна горутина пишет напрямую в стек другой горутины. После этого шага, канал выглядит точно так же, как сразу после инициализации. Обе горутины завершаются и программа выходит.

Так устроены синхронные каналы. Сейчас же, давайте посмотрим на буферизированные каналы.

### Буферезированные каналы

Рассмотрим следующий пример:

```go
package main

func main() {
    ch := make(chan bool, 1)
    ch <- true
    go func() {
        <-ch
    }()
    ch <- true
}
```

Опять же, порядок исполнения неизвестен, пример с первой читающей горутиной мы разобрали выше, поэтому сейчас допустим, что два значения были записаны в канал, и после этого один из элементов вычитан. И первым шагом идёт создание канала, который будет выглядеть вот так:

![img](https://habrastorage.org/files/6f4/e78/6af/6f4e786af89b47f49e0b52d1869a2180.png)

Разница в сравнении с синхронным каналом в том, что тут Go выделяет буфер и устанавливает значение `dataqsiz` в единицу.

Следующим шагом будет отправка первого значения в канал. Чтобы сделать это, горутина сначала производит несколько проверок: пуста ли очередь `recvq`, пуст ли буфер, достаточно ли места в буфере.

В нашем случае в буфере достаточно места и в очереди ожидания чтения нет горутин, поэтому горутина просто записывает элемент в буфер, увеличивает значение `qcount` и продолжает исполнение далее. Канал в этот момент выглядит так:

![img](https://habrastorage.org/files/40c/f56/e00/40cf56e008e44b21ab2bbf7a5afe8a5e.png)

На следующем шаге, горутина main отправляет следующее значение в канал. Когда буфер полон, буферизированный канал будет вести себя точно так же, как синхронный (небуферизированный) канал, тоесть горутина добавит себя в очередь ожидания и заблокируется, в результате чего, канал будет выглядеть следующим образом:

![img](https://habrastorage.org/files/279/503/8c4/2795038c432c4ff38041e67086cb4e56.png)

Сейчас горутина main заблокирована и Go запустил одну анонимную горутину, которая пытается прочесть значение из канала. И вот тут начинается хитрая часть. Go гарантирует, что канал работает по принципу FIFO очереди ([спецификация](https://golang.org/ref/spec#Channel_types)), но горутина не может просто взять значение из буфера и продолжить исполнение. В этом случае горутина main заблокируется навсегда. Для решения этой ситуации, текущая горутина читает данные из буфера, затем добавляет значение из заблокированной горутины в буфер, разблокирует ожидающую горутину и удаляет её из очереди ожидания. (В случае же, если нет ожидающих горутину, она просто читает первое значение из буфера)

### Select

Но постойте, Go же ещё поддерживает select с дефолтным поведением, и если канал заблокирован, как горутина сможет обработать default? Хороший вопрос, давайте быстро посмотрим на приватное API каналов. Когда вы запускаете следующий кусок кода:

```go
select {
    case <-ch:
    foo()
    default:
    bar()
}
```

Go запускает функцию со следующей сигнатурой:

```go
func chanrecv(t *chantype, c *hchan, ep unsafe.Pointer, block bool)
```

`chantype` это тип канала (например, bool в случае make(chan bool)), `hchan` — указатель на структуру канала, `ep` — указатель на сегмент памяти, куда должны быть записаны данные из канала, и последний, но самый интересный для нас — это аргумент `block`. Если он установлен в `false`, то функция будет работать в неблокирующем режиме. В этом режиме горутина проверяет буфер и очередь, возвращает `true` и пишет данные в `ep` или возвращает `false`, если нет данных в буфере или нет отправителей в очереди. Проверки буфера и очереди реализованы как атомарные операции, и не требуют блокировки мьютекса.

Также есть функция для записи данных в очередь с аналогичной сигнатурой.

Мы разобрались как работают запись и чтение из канала, давайте теперь взглянём, что происходит при закрытии канала.

### Закрытие канала

Закрытие канала это простая операция. Go проходит по всем ожидающим на чтение или запись горутинам и разблокирует их. Все получатели получают дефолтные значение переменных того типа данных канала, а все отправители паникуют.



## Вопросы

- Как хранятся переменные в Golang?
- Как устроен пустой интерфейс?
- Как устроен слайс и чем он отличается от массива?
- Как создать многомерный массив в Golang
- Нужно ли передавать slice по ссылке в фукнцию?
- Что происходит в runtime Golang?
- В чем различия goroutine от потока системы?
- Как огранить число потоков на системы при запуске Golang программы и возможно ли огранить их до 1 потока?
- Что такое каналы и каких видов они бывают? Что будет если писать в закрытый канал? Что будет если писать в неинициализированный канал?
- Как в golang освобождаетс память и можно ли отключить это поведение и зачем это делать?
- Расскажите о ООП в Golang



## *Дополнительно:*

- [Исходный код](https://golang.org/src/runtime/chan.go)
- [Каналы в спецификации Go](https://golang.org/ref/spec#Channel_types)
- [Каналы Go на стероидах](https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub)
- [Планировщик Go](https://habr.com/ru/company/ua-hosting/blog/269271/)
- [Work-stealing планировщик в Go](https://habr.com/ru/post/333654/)
- [Как не наступать на грабли в Go](https://habr.com/ru/post/325468)
- [Go Traps](https://go-traps.appspot.com/)
- [Хэш таблицы в Go. Детали реализации](https://habr.com/ru/post/457728)
- [Algorithms to Go](https://yourbasic.org/)
- [Практичный Go: советы по написанию поддерживаемых программ в реальном мире](https://habr.com/ru/post/441842/)
- [50 оттенков Go: ловушки, подводные камни и распространённые ошибки новичков](https://habr.com/ru/company/mailru/blog/314804/)