# Основы Linux

## Команды Управление файлами

**ls**

Утилита для просмотра содержимого каталогов. По умолчанию показывает текущий каталог. Если в параметрах передать путь, то она перечислит содержимое того каталога. Полезные опции -l (List) и -a (All). Первая форматирует вывод в виде списка с более подробной информацией, а вторая включает показ скрытых файлов.

**cat**

Печатает содержимое файла, переданного в параметре, в стандартный вывод. Если передать несколько файлов, команда склеит их. Также можно перенаправить вывод в еще один файл, с помощью символа '&gt;'. Если нужно вывести только определенное количество строк используйте опцию -n (Number).

**cd**

Позволяет перейти из текущего каталога, в указанный. Если запустить без параметров - возвращает в домашний каталог. Вызов с двумя точками возвращает на уровень вверх относительно текущего каталога. Вызов с тире (cd -) возвращает к предыдущему каталогу.

**pwd**

Печатает на экран текущий каталог. Это может быть полезно, если ваша командная строка Linux не выводит такую информацию, а также особенно полезно в Bash программировании, для получения ссылки на каталог в котором выполняется скрипт.

**mkdir**

Создание новых каталогов. Наиболее удобная опция - p (Parents), позволяет создать всю структуру подкаталогов одной командой, даже если они еще не существуют.

**file**

Показывает тип файла. В Linux файлы не обязаны всегда иметь расширения для того, чтобы с ними работать. Поэтому пользователю иногда трудно определить, что за файл перед ним. Эта маленькая утилита решает проблему.

**cp**

Копирование файлов и каталогов. Она не копирует каталоги рекурсивно по умолчанию, поэтому не забудьте добавить опцию -r (Recursive) или -a (Archive). Последняя включает режим сохранения атрибутов, владельца и временного штампа, в дополнение к рекурсивному копированию.

**mv**

Перемещение или переименование файлов и каталогов. Примечательно, что переименование и перемещение - это одна и та же операция. Переименование - это перемещение файла в ту же папку с другим именем.

**rm**

Удаляет файлы и папки. Очень полезная команда Linux, с помощью нее вы можете убрать весь беспорядок. Однако будьте осторожны при ее использовании. Хоть и для того чтобы повредить систему вам нужно серьезно постараться, вы можете удалить собственные важные файлы. Rm не удаляет файлы в корзину, из которой потом все можно будет восстановить. Так что будьте осторожны, чтобы потом не говорили: "rm съела мою курсовую". Все действия необратимы. Если нужно рекурсивное удаление, используйте опцию -r.

**ln**

Создает жесткие или символические ссылки на файлы. Символические или программные ссылки - это что-то похожее на ярлыки в Windows. Они предоставляют удобный способ доступа к определенному файлу. Символические ссылки указывают на файл, но не имеют никаких метаданных. Жесткие ссылки в отличие от символических указывают на физический адрес области диска, где хранятся данные файла.

**chmod**

`chmod опции права /путь/к/файлу`

Изменяет права доступа к файлу. 

 Есть три основных вида прав:

- **r** - чтение;
- **w** - запись;
- **x** - выполнение;
- **s** - выполнение  от имени суперпользователя (дополнительный);

Также есть три категории пользователей, для которых вы можете установить эти права на файл linux:

- **u** - владелец файла;
- **g** - группа файла;
- **o** - все остальные пользователи;

Наиболее популярен восьмеричный формат задания прав:

- **0** - никаких прав;
- **1** - **только выполнение**;
- **2** - **только запись**;
- **3** - выполнение и запись;
- **4** -  **только чтение**;
- **5** - чтение и выполнение;
- **6** - чтение и запись;
- **7** - чтение запись и выполнение.

Например:

- **744** - разрешить все для владельца, а остальным только чтение;
- **755** - все для владельца, остальным только чтение и выполнение;
- **764** - все для владельца, чтение и запись для группы, и только чтение для остальных;
- **777** - всем разрешено все.

**chown**

Изменяющая владельца и/или группу для указанных файлов. Только суперпользователь может изменять владельцев. Для рекурсивного изменения используйте опцию -R.

Поменять владельца для `strace.log` в 'rob' и идентификатор группы в 'developers'.

```bash
chown rob:developers strace.log
```

**find**

Поиск в файловой системе, файлов и папок. Это очень гибкая и мощная команда Linux не только из-за своих возможностей поиска, но и благодаря возможности выполнять произвольные команды для найденных файлов.

**locate**

В отличие от find ведет поиск в базе данных updatedb, для шаблонов имен файлов. Эта база данных содержит снимок файловой системы, что позволяет искать очень быстро. Но этот поиск ненадежен, потому что вы не можете быть уверены, что ничего не изменилось с момента последнего снимка.

**du**

(disk usage) Показать размер файла или каталога. Одни из наиболее полезных опций - h (Human), которая преобразует размеры файлов в легко читаемый формат, -s (Summarize) выводит минимум данных и -d (Depth) - устанавливает глубину рекурсии по каталогам. 

```du [опции][каталоги_или_файлы]```

Опции:

-  –b  выводит информацию в байтах(а не в килобайтах).
- –c  выводит итоговую информацию об использовании дисковой памяти.
- –k  выводит информацию в килобайтах(по умолчанию).
- –s  выводит итоговую информацию об использовании дискового пространства без информации о каталогах.
- -h  вывести иноформацию в человекочитаемом виде.
- -d (Depth) - устанавливает глубину рекурсии по каталогам. 

**df**

**df**(disk free) - позволяет узнать размер свободного и занятого пространства во всех смонтированных файловых системах.

```df [опции][файловая_система]```

Опции:

- -a       выводит информацию обо всех файловых системах.
- -h       выводит размеры в удобном для человека виде (мегабайты, килобайты, гигабайты и т.д.)
- -T       показать тип файловой системы.
- -t        выводит информацию только об указанных типах файловых систем.

**dd**

Как сказано в официальном руководстве, это команда терминала для копирования и преобразования файлов. Не очень понятное описание, но это все что делает dd. Вы передаете ей файл-источник и пункт назначения, и пару дополнительных опций. Затем она делает копию одного файла в другой. Вы можете задать точный размер данных, которые нужно записать или скопировать. Работает утилита со всеми устройствами. Например, если вы хотите перезаписать жесткий диск нулями из /dev/zero, можете сделать это. Также она часто используется для создания LiveUSB или гибридных ISO образов.

**mount /umount**

Это команды консоли Linux для подключения и отключения файловых систем Linux. Можно подключать все, от USB накопителей, до ISO образов. И только у суперпользователя есть права для этого.

## Работа с текстом

**more/less**

Это две простенькие команды терминала, для просмотра длинных текстов, которые не вмещаются на одном экране. Представьте себе очень длинный вывод команды. Или вы вызвали cat для просмотра файла и вашему эмулятору терминала потребовалось несколько секунд, чтобы прокрутить весь текст. Если ваш терминал не поддерживает прокрутки, вы можете сделать это с помощью less. Less новее, чем more и поддерживает больше опций, поэтому использовать more нет причин.

**head/tail**

Еще одна пара, но здесь у каждой команды своя область применения. Head выводит несколько первых строк из файла (голова), а tail выдает несколько последних строк (хвост). По умолчанию каждая утилита выводит десять строк. Но это можно изменить с помощью опции -n. Еще один полезный параметр -f. Это сокращение от Follow (следовать), утилита постоянно выводит изменения в файле на экран. Например, если вы хотите следить за лог файлом, вместо того чтобы постоянно открывать и закрывать его используйте tail -nf.

**grep**

Grep как и другие инструменты Linux делает одно действие, но делает его хорошо. Она ищет текст по шаблону. По умолчанию она принимает стандартный ввод, но вы можете искать в файлах. Шаблон может быть строкой, или регулярным выражением. Она может вывести как совпадающие, так и несовпадающие строки и их контекст. Каждый раз, когда вы выполняете команду, которая выдает очень много информации, не нужно анализировать все вручную, пусть grep делает свою магию.

**sort**

Сортировка строк текста по различным критериям. Наиболее полезные: -n (Numeric) - по числовому значению, и -r (Reverse), которая переворачивает вывод. Это может быть полезно для сортировки вывода du. Например, если хотите отсортировать файлы по размеру, просто соедините эти команды.

**wc**

wc(word count) -Утилита командной строки Linux для подсчета количества слов, строк, байт и символов.

```bash
 wc -l <filename> вывести количество строк
 wc -c <filename> вывести количество байт
 wc -m <filename> вывести количество символов
 wc -L <filename> вывести длину самой длинной строки
 wc -w <filename> вывести количество слов
```

**uniq**

Утилита Unix, с помощью которой можно вывести или отфильтровать повторяющиеся строки в отсортированном файле. Если входной файл задан как («-») или не задан вовсе, чтение производится из стандартного ввода. Если выходной файл не задан, запись производится в стандартный вывод. Вторая и последующие копии повторяющихся соседних строк не записываются. Повторяющиеся входные строки не распознаются, если они не следуют строго друг за другом, поэтому может потребоваться предварительная сортировка файлов.

```
uniq [-c | -d | -u] [-i] [-f число_полей] [-s | -w число_символов] [входной_файл [выходной_файл]]
```
Опции:
- `-u` Выводить только те строки, которые не повторяются на входе.
- `-d` Выводить только те строки, которые повторяются на входе.
- `-c` Перед каждой строкой выводить число повторений этой строки на входе и один пробел.
- `-i` Сравнивать строки без учёта регистра.
- `-s число_символов` Определяет количество символов, начиная с начала строки, игнорируемых при сравнении. Все остальные символы сравниваются. Символы нумеруются начиная с единицы.
- `-w число символов` Определяет количество символов, начиная с начала строки, участвующих в сравнении. Все остальные символы игнорируются.
- `-f число_полей`  Игнорировать при сравнении первые число_полей полей каждой строки ввода. Полем является строка непробельных символов, отделённая от соседних полей пробельными символами. Поля нумеруются начиная с единицы.

**diff**

Показывает различия между двумя файлами, в построчном сравнении. Причем выводятся только строки, в которых обнаружены отличия. Измененные строки отмечаются символом "с", удаленные - "d", а новые - "а".

## Управление процессам

**kill / xkill / pkill / killall**

Все они служат для завершения процессов. Но они принимают различные параметры для идентификации процессов. **Kill** нужен PID процесса, xkill - достаточно кликнуть по окну, чтобы закрыть его, **killall** и **pkill** принимают имя процесса. 

**Команда killall** в Linux предназначена для «убийства» всех процессов, имеющих одно и то же имя. Это удобно, так как нам не нужно знать PID процесса. Например, мы хотим закрыть все процессы с именем gcalctool. Выполните в терминале:

```bash
killall gcalctool
```

Команда killall, также как и kill, по умолчанию шлет сигнал SIGTERM. Чтобы послать другой сигнал нужно воспользоваться опцией *-s*. Например:

```bash
killall -s 9 gcalctool
```

Когда вы выполняете команду "kill", то фактически вы посылаете системе сигнал, чтобы заставить ее завершить некорректно ведущее себя приложение. Всего вы можете использовать до 60 сигналов, но все, что нужно знать, это SIGTERM (15) и SIGKILL (9).

**SIGTERM** –  Этот сигнал запрашивает остановку процесса который работает. Этот сигнал может быть проигнорирован.Процессу дается время, чтобы хорошо выключился. Когда программа хорошо выключается, это означает, что ей дано время, чтобы спасти его прогресс и освободить ресурсы. Другими словами, он не «forced» прекращение работы процесса.

**SIGKILL** –  сигнал SIGKILL заставляет процесс прекратить выполнение своей работы немедленно. Программа не может игнорировать этот сигнал. Несохраненный прогресс будет потерян.

Вы можете просмотреть все сигналы с помощью команды:

```bash
$ kill -l
```

Вот некоторые:

| N    | Имя  | Описание                                                     | Можно перехватывать | Можно блокировать |
| ---- | ---- | ------------------------------------------------------------ | ------------------- | ----------------- |
| 1    | HUP  | Hangup. Отбой                                                | Да                  | Да                |
| 2    | INT  | Interrupt. В случае выполнения простых команд вызывает прекращение выполнения, в интерактивных программах - прекращение активного процесса | Да                  | Да                |
| 3    | QUIT | Как правило, сильнее сигнала Interrupt                       | Да                  | Да                |
| 4    | ILL  | Illegal Instruction. Центральный процессор столкнулся с незнакомой командой (в большинстве случаев это означает, что допущена программная ошибка). Сигнал отправляется программе, в которой возникла проблема | Да                  | Да                |
| 8    | FPE  | Floating Point Exception. Вычислительная ошибка, например, деление на ноль | Да                  | Да                |
| 9    | KILL | Всегда прекращает выполнение процесса                        | Нет                 | Нет               |
| 11   | SEGV | Segmentation Violation. Доступ к недозволенной области памяти | Да                  | Да                |
| 13   | PIPE | Была предпринята попытка передачи данных с помощью конвейера или очереди FIFO, однако не существует процесса, способного принять эти данные | Да                  | Да                |
| 15   | TERM | Software Termination. Требование закончить процесс (программное завершение) | Да                  | Да                |

​	

**ps / pgrep**

Команда ps выдает информацию об активных процессах. По умолчанию информация дается только о процессах, ассоциированных с данным терминалом. Выводятся идентификатор процесса, идентификатор терминала, истраченное к данному моменту время ЦП и имя команды. Если нужна иная информация, следует пользоваться опциями. Одна из самых распространенных комбинаций флагов: `ps aux` Выводятся все процессы, выполняющиеся от имени всех пользователей (выводит статистику, время старта процесса и команду, которая его стартовала)

**top / htop**

Обе команды похожи, обе отображают процессы, и могут быть использованы как консольные системные мониторы. Я рекомендую установить htop, если в вашем дистрибутиве он не поставляется по умолчанию, так как это намного улучшенная версия top. Вы сможете не только просматривать, но и контролировать процессы через его интерактивный интерфейс.

**time**

Время выполнения процесса. Это секундомер для выполнения программы. Полезно если вам интересно насколько сильно ваша реализация алгоритма отстает от стандартной. Но несмотря на такое название она не сообщит вам текущее время, используйте для этого команду date.

## Пользовательское окружение

**su / sudo**

Su и sudo - это два способа выполнить одну и ту же задачу - запустить программу от имени другого пользователя. В зависимости от вашего дистрибутива, вы, наверное, используете одну или другую. Но работают обе. Разница в том, что su переключает вас на другого пользователя, а sudo только выполняет команду от его имени. Поэтому использование sudo будет наиболее безопасным вариантом работы.

**сhroot** 

Операция изменения корневого каталога диска для запущенного процесса и его дочерних процессов. Программа, запущенная в таком окружении не может получить доступ к файлам вне нового корневого каталога. Это измененное окружение называется chroot jail.

**date**

В отличие от time, делает именно то, чего вы от него и ожидаете - выводит дату и время в стандартный вывод. Вывод можно форматировать, в зависимости от ваших потребностей: вывести год, месяц, день, установить 12-ти или 24-ти часовой формат, получить наносекунды или номер недели. Например, date +"%j %V", выведет день в году и номер недели в формате ISO.

**alias**

Эта команда создает синонимы для других команд Linux. Это означает, что вы можете делать новые команды или группы команд, а также переименовывать существующие. Это очень удобно для сокращения длинных команд, которые вы часто используете, или создания более понятных имен для команд которые вы используете нечасто и не можете запомнить.

**uname**

Выводит некоторую основную информацию о системе. Без параметров она не покажет ничего полезного, кроме строчки Linux, но если задать параметр -a (All) можно получить информацию о ядре, имени хоста и узнать архитектуру процессора.

**uptime**

Сообщает вам время работы системы. Не очень существенная информация, но может быть полезна для случайных вычислений или просто ради интереса, как давно был перезагружен сервер.

**sleep**

Вам, наверное, интересно как же ее можно использовать. Но даже кроме Bash скриптинга, у нее есть свои преимущества. Например, если вы хотите выключить компьютер через определенный промежуток времени, или в качестве импровизированной тревоги.

## Управления пользователями

**useradd / userdel / usermod**

Эти команды консоли Linux позволяют вам добавлять, удалять и изменять учетные записи пользователей. Скорее всего, вы не будете использовать их очень часто. Особенно если это домашний компьютер, и вы являетесь единственным пользователем. И даже если нет, управлять пользователями можно с помощью графического интерфейса, но лучше о них знать на случай, если вдруг понадобится.

**passwd**

Эта команда позволяет изменить пароль учетной записи пользователя. Как суперпользователь, вы можете сбросить пароли всех пользователей, несмотря на то, что не можете их увидеть. Хорошая практика безопасности - менять пароль не очень редко.

#### Linux команды для просмотра документации

**man / whatis**

Команда man открывает руководство по определенной команде. Для всех основных команд Linux есть man страницы. Whatis какие разделы руководств есть для данной команды.

**whereis**

Показывает полный путь к исполняемому файлу программы. Также может показать путь к исходникам если они есть в системе.

### Команды Linux для управления сетью

**ip**

Если список команд Linux для управления сетью вам кажется слишком коротким, скорее всего, вы незнакомы с утилитой ip. В пакете net-tools содержится множество других утилит ipconfig, netstat и другие устаревшие, вроде iproute2. Все это заменяет одна утилита - ip. Вы можете рассматривать ее как швейцарский армейский нож для работы с сетью, или непонятную массу, но в любом случае за ней будущее.

**ping**

Ping - это ICMP ECHO\_REQUEST дейтаграммы, но на самом деле это неважно. Важно то, что утилита ping может быть очень полезным диагностическим инструментом. Она поможет быстро проверить подключены ли вы к маршрутизатору или к интернету, и дает кое-какое представление о качестве этой связи.

**nethogs**

Если у вас медленный интернет, то вам, наверное, было бы интересно знать сколько трафика использует та или иная программа в Linux, или вообще какая программа потребляет всю скорость. Теперь это можно сделать с помощью утилиты nethogs. Для того чтобы задать сетевой интерфейс используйте опцию -i.

**traceroute**

Это усовершенствованная версия ping. Кроме непосредственно доступности узла, мы можем увидеть полный маршрут сетевых пакетов, а также время доставки их на каждый узел.

## Рецепты

**Копируем файл/папку с сервера на сервер**

```sh
scp -r /path/from/destination username@hostname:/path/to/destination
```

**Мониторим состояние сервера**

**Ищем логи**

**Системные вызовы скрипта пхп**

**Слушатель 80 порта**

**Посчитать топ 10 адресов в логах**

```bash
less /var/log/nginx/access.log | cut -d' ' -f1 | sort | uniq -c
```

Разберём подробно:

1. `less` — утилита для вывода содержимого файла /var/log/nginx/access.log. Указываем путь до нужного access-лога.
2. `cut -d' ' -f1` — разбиваем строку на подстроки разделителем "пробел". Разделитель указывается флагом -d. Флагом -f указываем порядковый номер поля, которое будет отображаться в выводе. В данном случае «1» - первое поле, это и есть ip-адресс.
3. `sort`  — сортировка строк по порядку. Команда сгруппирует одинаковые строки "рядом". Команда sort необходима для корректной работы следующей команды - `uniq`.
4. `uniq`— выведет только уникальные строки. Т.е. в результате будут только уникальные ip-адреса.
5.  Для вывода количества, нужно добавить флаг `-с` (от слова **c**ount) к команде `uniq`:

Ищем с каких серверов демон получает запросы


**.bashrc**
Файл ~/.bashrc определяет поведение командной оболочки для конкретного пользователя(переменных окружения например). Загружается каждый раз, когда пользователь создает терминальный сеанс, то есть проще говоря, открывает новый терминал. Все переменные окружения, созданные в этом файле вступают в силу каждый раз когда началась новая терминальная сессия.


## CТРУКТУРА ФАЙЛОВОЙ СИСТЕМЫ LINUX

### / - КОРЕНЬ

Это главный каталог в системе Linux. По сути, это и есть файловая система Linux. Здесь нет дисков или чего-то подобного, как в Windows. Вместо этого, адреса всех файлов начинаются с корня, а дополнительные разделы, флешки или оптические диски подключаются в папки корневого каталога. Только пользователь root имеет право читать и изменять файлы в этом каталоге. Обратите внимание, что у пользователя root домашний каталог /root, но не сам /.

### /BIN - (BINARIES) БИНАРНЫЕ ФАЙЛЫ ПОЛЬЗОВАТЕЛЯ

Этот каталог содержит исполняемые файлы. Здесь расположены программы, которые можно использовать в однопользовательском режиме или режиме восстановления. Одним словом, те утилиты, которые могут использоваться пока еще не подключен каталог /usr/. Это такие общие команды, как cat, ls, tail, ps и т д.

### /SBIN - (SYSTEM BINARIES) СИСТЕМНЫЕ ИСПОЛНЯЕМЫЕ ФАЙЛЫ

Так же как и /bin, содержит двоичные исполняемые файлы, которые доступны на ранних этапах загрузки, когда не примонтирован каталог /usr. Но здесь находятся программы, которые можно выполнять только с правами суперпользователя. Это разные утилиты для обслуживания системы. Например, iptables, reboot, fdisk, ifconfig,swapon и т д.

### /ETC - (ETCETERA) КОНФИГУРАЦИОННЫЕ ФАЙЛЫ

В этой папке содержатся конфигурационные файлы всех программ, установленных в системе.

Кроме конфигурационных файлов, в системе инициализации Init Scripts, здесь находятся скрипты запуска и завершения системных демонов, монтирования файловых систем и автозагрузки программ. Структура каталогов linux в этой папке может быть немного запутанной, но предназначение всех их - настройка и конфигурация.

### /DEV - (DEVICES) ФАЙЛЫ УСТРОЙСТВ

В Linux все, в том числе внешние устройства являются файлами. Таким образом, все подключенные флешки, клавиатуры, микрофоны, камеры - это просто файлы в каталоге /dev/. Этот каталог содержит не совсем обычную файловую систему. Структура файловой системы Linux и содержащиеся в папке /dev файлы инициализируются при загрузке системы, сервисом udev. Выполняется сканирование всех подключенных устройств и создание для них специальных файлов. Это такие устройства, как: /dev/sda, /dev/sr0, /dev/tty1, /dev/usbmon0 и т д.

### /PROC - (PROCCESS) ИНФОРМАЦИЯ О ПРОЦЕССАХ

Это тоже необычная файловая система, а подсистема, динамически создаваемая ядром. Здесь содержится вся информация о запущенных процессах в реальном времени. По сути, это псевдофайловая система, содержащая подробную информацию о каждом процессе, его Pid, имя исполняемого файла, параметры запуска, доступ к оперативной памяти и так далее. Также здесь можно найти информацию об использовании системных ресурсов, например, /proc/cpuinfo, /proc/meminfo или /proc/uptime. Кроме файлов в этом каталоге есть большая структура папок linux, из которых можно узнать достаточно много информации о системе.

### /VAR (VARIABLE) - ПЕРЕМЕННЫЕ ФАЙЛЫ

Название каталога /var говорит само за себя, он должен содержать файлы, которые часто изменяются. Размер этих файлов постоянно увеличивается. Здесь содержатся файлы системных журналов, различные кеши, базы данных и так далее. Дальше рассмотрим назначение каталогов Linux в папке /var/.

### /VAR/LOG - ФАЙЛЫ ЛОГОВ

Здесь содержатся большинство файлов логов всех программ, установленных в операционной системе. У многих программ есть свои подкаталоги в этой папке, например, /var/log/apache - логи веб-сервера, /var/log/squid - файлы журналов кеширующего сервера squid. Если в системе что-либо сломалось, скорее всего, ответы вы найдете здесь.

### /VAR/LIB - БАЗЫ ДАННЫХ

Еще один тип изменяемых файлов - это файлы баз данных, пакеты, сохраненные пакетным менеджером и т д.

### /VAR/MAIL - ПОЧТА

В эту папку почтовый сервер складывает все полученные или отправленные электронные письма, здесь же могут находиться его логи и файлы конфигурации.

### /VAR/SPOOL - ПРИНТЕР

Изначально, эта папка отвечала за очереди печати на принтере и работу набора программ cpus.

### /VAR/LOCK - ФАЙЛЫ БЛОКИРОВОК

Здесь находятся файлы блокировок. Эти файлы означают, что определенный ресурс, файл или устройство занят и не может быть использован другим процессом. Apt-get, например, блокирует свою базу данных, чтобы другие программы не могли ее использовать, пока программа с ней работает.

### /VAR/RUN - PID ПРОЦЕССОВ

Содержит файлы с PID процессов, которые могут быть использованы, для взаимодействия между программами. В отличие от каталога /run данные сохраняются после перезагрузки.

### /TMP (TEMP) - ВРЕМЕННЫЕ ФАЙЛЫ

В этом каталоге содержатся временные файлы, созданные системой, любыми программами или пользователями. Все пользователи имеют право записи в эту директорию.Файлы удаляются при каждой перезагрузке. Аналогом Windows является папка Windows\Temp, здесь тоже хранятся все временные файлы.

### /USR - (USER APPLICATIONS) ПРОГРАММЫ ПОЛЬЗОВАТЕЛЯ

Это самый большой каталог с большим количеством функций. Тут наиболее большая структура каталогов Linux. Здесь находятся исполняемые файлы, исходники программ, различные ресурсы приложений, картинки, музыку и документацию.

### /USR/BIN/ - ИСПОЛНЯЕМЫЕ ФАЙЛЫ

Содержит исполняемые файлы различных программ, которые не нужны на первых этапах загрузки системы, например, музыкальные плееры, графические редакторы, браузеры и так далее.

### /USR/SBIN/

Содержит двоичные файлы программ для системного администрирования, которые нужно выполнять с правами суперпользователя. Например, таких как Gparted, sshd, useradd, userdel и т д.

### /USR/LIB/ - БИБЛИОТЕКИ

Содержит библиотеки для программ из /usr/bin или /usr/sbin.

### /USR/LOCAL - ФАЙЛЫ ПОЛЬЗОВАТЕЛЯ

Содержит файлы программ, библиотек, и настроек созданные пользователем. Например, здесь могут храниться программы собранные и установленные из исходников и скрипты, написанные вручную.

### /HOME - ДОМАШНЯЯ ПАПКА

В этой папке хранятся домашние каталоги всех пользователей. В них они могут хранить свои личные файлы, настройки программ и т д. Например, /home/sergiy и т д. Если сравнивать с Windows, то это ваша папка пользователя на диске C, но в отличии от WIndows, home как правило размещается на отдельном разделе, поэтому при переустановке системы все ваши данные и настройки программ сохранятся.

### /BOOT - ФАЙЛЫ ЗАГРУЗЧИКА

Содержит все файлы, связанные с загрузчиком системы. Это ядро vmlinuz, образ initrd, а также файлы загрузчика, находящие в каталоге /boot/grub.

### /LIB (LIBRARY) - СИСТЕМНЫЕ БИБЛИОТЕКИ

Содержит файлы системных библиотек, которые используются исполняемыми файлами в каталогах /bin и /sbin.

Библиотеки имеют имена файлов с расширением *.so и начинаются с префикса lib*. Например, libncurses.so.5.7. Папка /lib64 в 64 битных системах содержит 64 битные версии библиотек из /lib. Эту папку можно сравнить с WIndows\system32, там тоже сгружены все библиотеки системы, только там они лежат смешанные с исполняемыми файлами, а здесь все отдельно.

### /OPT (OPTIONAL APPLICATIONS) - ДОПОЛНИТЕЛЬНЫЕ ПРОГРАММЫ

В эту папку устанавливаются проприетарные программы, игры или драйвера. Это программы созданные в виде отдельных исполняемых файлов самими производителями. Такие программы устанавливаются в под-каталоги /opt/, они очень похожи на программы Windows, все исполняемые файлы, библиотеки и файлы конфигурации находятся в одной папке.

### /MNT (MOUNT) - МОНТИРОВАНИЕ

В этот каталог системные администраторы могут монтировать внешние или дополнительные файловые системы.

### /MEDIA - СЪЕМНЫЕ НОСИТЕЛИ

В этот каталог система монтирует все подключаемые внешние накопители - USB флешки, оптические диски и другие носители информации.

### /SRV (SERVER) - СЕРВЕР

В этом каталоге содержатся файлы серверов и сервисов. Например, могут содержаться файлы веб-сервера apache.

### /RUN - ПРОЦЕССЫ

Еще один каталог, содержащий PID файлы процессов, похожий на /var/run, но в отличие от него, он размещен в TMPFS, а поэтому после перезагрузки все файлы теряются.

### /SYS (SYSTEM) - ИНФОРМАЦИЯ О СИСТЕМЕ

Назначение каталогов Linux из этой папки - получение информации о системе непосредственно от ядра. Это еще одна файловая система организуемая ядром и позволяющая просматривать и изменить многие параметры работы системы, например, работу swap, контролировать вентиляторы и многое другое.

*Дополнительно:*

- https://habr.com/post/280093/
- https://habr.com/company/ruvds/blog/323330/
- http://rus-linux.net/MyLDP/server/monitoring-servera-v-konsoli.html
- [CТРУКТУРА ФАЙЛОВОЙ СИСТЕМЫ LINUX](https://losst.ru/ctruktura-fajlovoj-sistemy-linux)